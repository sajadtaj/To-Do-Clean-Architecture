### سوال 1: نقش اصلی لایه کاربرد (Application Layer) در معماری تمیز چیست؟

<div dir="rtl" style="text-align: right;">
**پاسخ:** نقش اصلی لایه کاربرد در معماری تمیز، **تنظیم و هماهنگی** (orchestration) اشیاء دامنه‌ای برای انجام موارد استفاده (use cases) خاص است. این لایه به عنوان یک میانجی بین لایه دامنه (که موجودیت‌های اصلی کسب‌وکار را در بر می‌گیرد) و لایه‌های بیرونی سیستم عمل می‌کند. لایه کاربرد اطمینان می‌دهد که قوانین کسب‌وکار به‌درستی اعمال می‌شوند و همچنین مسئولیت‌هایی از قبیل **هماهنگی عملیات، مدیریت تراکنش‌ها، اعتبارسنجی ورودی، و ترجمه داده‌ها** را بر عهده دارد.
</div>

### سوال 2: چرا در لایه کاربرد از الگوهای نوع نتیجه (Result Type) برای مدیریت خطا استفاده می‌شود، و این رویکرد چه مزایایی دارد؟

<div dir="rtl" style="text-align: right;">
**پاسخ:** در لایه کاربرد، استفاده از الگوهای نوع نتیجه (Result Type) به جای صرفاً تکیه بر استثناها (exceptions)، روش ترجیحی برای مدیریت خطا است. این الگو، یک رابط صریح و یکپارچه برای رسیدگی به **موفقیت‌ها و شکست‌های یک عملیات** ارائه می‌دهد. مزایای این رویکرد عبارتند از:
*   **مسیرهای خطا را صریح می‌کند**: امضا (signature) توابع به وضوح نشان می‌دهد که هم نتیجه موفقیت‌آمیز و هم وضعیت شکست ممکن است رخ دهد.
*   **مدیریت خطای یکپارچه**: به جای اینکه هر نوع خطا به روش متفاوتی (از طریق استثنائات مختلف) مدیریت شود، همه خطاها از طریق یک شیء `Result.failure()` استاندارد برگردانده می‌شوند.
*   **ترجمه خطاهای دامنه**: خطاهای خاص دامنه (مانند `ProjectNotFoundError`) به خطاهای سطح برنامه (مانند `Error.not_found()`) در مرز لایه ترجمه می‌شوند.
*   **شفافیت در تست‌پذیری**: تست کردن هر دو حالت موفقیت و شکست آسان‌تر می‌شود، زیرا می‌توان وضعیت شیء `Result` را بررسی کرد به جای اینکه بخواهیم استثنائات را بگیریم.

مثال ساختار `Error` و `Result`:
</div>

```python
@dataclass(frozen=True)
class Error:
    code: ErrorCode
    message: str
    details: Optional[dict[str, Any]] = None

@dataclass(frozen=True)
class Result:
    value: Any = None
    error: Optional[Error] = None

    @property
    def is_success(self) -> bool:
        return self.error is None

    @classmethod
    def success(cls, value: Any) -> Self:
        return cls(value=value)

    @classmethod
    def failure(cls, error: Error) -> Self:
        return cls(error=error)
```

<div dir="rtl" style="text-align: right;">

### سوال 3: سه الگوی بنیادی که در لایه کاربرد برای حفظ مرزهای معماری تمیز با هم کار می‌کنند، کدامند؟

<div dir="rtl" style="text-align: right;">
**پاسخ:** سه الگوی بنیادی که در لایه کاربرد برای حفظ مرزهای معماری تمیز با هم کار می‌کنند، عبارتند از:
*   **اینتراکتورهای مورد استفاده (Use Case Interactors)**: این‌ها ارکستراتورهای اصلی هستند که عملیات‌های کسب‌وکار خاص را پیاده‌سازی می‌کنند، در حالی که تراکنش‌ها را مدیریت کرده و اشیاء دامنه را هماهنگ می‌سازند. آنها اطمینان می‌دهند که هر عملیات متمرکز و اجرای آن یکپارچه است.
*   **مرزهای رابط (Interface Boundaries)**: این مرزها قراردادهای واضحی را بین لایه کاربرد و سرویس‌هایی که به آنها وابسته است، برقرار می‌کنند.
*   **وارونگی وابستگی (Dependency Inversion)**: این الگو امکان پیاده‌سازی انعطاف‌پذیر و تست‌پذیری مستقیم را از طریق این مرزها فراهم می‌کند و تضمین می‌کند که منطق اصلی کسب‌وکار از نگرانی‌های خارجی جدا باقی می‌ماند.
</div>

### سوال 4: اینتراکتورهای مورد استفاده (Use Case Interactors) چه چیزی هستند و چگونه در لایه کاربرد ساختاربندی می‌شوند؟

<div dir="rtl" style="text-align: right;">
**پاسخ:** اینتراکتورهای مورد استفاده **کلاس‌های بتنی** (concrete classes) هستند که قوانین کسب‌وکار خاص برنامه را پیاده‌سازی می‌کنند. آنها مسئول هماهنگی اشیاء دامنه و انجام عملیات بر اساس نیازهای برنامه هستند.

یک اینتراکتور مورد استفاده خوب طراحی شده به طور معمول دارای ساختار زیر است:
*   **وابستگی‌ها از طریق سازنده تزریق می‌شوند** (Dependency Injection). این وابستگی‌ها معمولاً رابط‌های انتزاعی (abstract interfaces) مانند مخازن (repositories) و سرویس‌های اعلان (notification services) هستند.
*   یک **متد عمومی `execute`** دارد که ورودی مورد استفاده را می‌پذیرد.
*   یک **شیء `Result`** را برمی‌گرداند که نشان‌دهنده موفقیت یا شکست عملیات است.
*   مسئول **اعتبارسنجی ورودی، هماهنگی عملیات روی اشیاء دامنه، و ترجمه خطاهای دامنه به خطاهای سطح برنامه** است.
</div>

```python
@dataclass(frozen=True)
class CompleteTaskUseCase:
    task_repository: TaskRepository
    notification_service: NotificationPort

    def execute(self, request: CompleteTaskRequest) -> Result:
        try:
            # Input validation and orchestration logic
            task = self.task_repository.get(request.task_id)
            task.complete(notes=request.completion_notes)
            self.task_repository.save(task)
            self.notification_service.notify_task_completed(task)
            return Result.success(TaskResponse.from_entity(task))
        except TaskNotFoundError:
            return Result.failure(Error.not_found("Task", str(request.task_id)))
        except ValidationError as e:
            return Result.failure(Error.validation_error(str(e)))
```

<div dir="rtl" style="text-align: right;">

### سوال 5: تزریق وابستگی (Dependency Injection) چگونه در لایه کاربرد به حفظ مرزهای معماری تمیز کمک می‌کند؟

<div dir="rtl" style="text-align: right;">
**پاسخ:** تزریق وابستگی یک اصل کلیدی در لایه کاربرد است که به حفظ مرزهای معماری تمیز کمک می‌کند. به جای اینکه یک کلاس به طور مستقیم نمونه‌ای از یک وابستگی بتنی (concrete dependency) را ایجاد کند، وابستگی‌ها از طریق سازنده (constructor) یا متدها به آن تزریق می‌شوند. این رویکرد مزایای متعددی دارد:
*   **کاهش وابستگی‌های بتنی**: لایه کاربرد (و به طور خاص، اینتراکتورهای مورد استفاده) به **رابط‌های انتزاعی** (abstract interfaces) مانند `TaskRepository` یا `NotificationService` وابسته می‌مانند، نه به پیاده‌سازی‌های بتنی آنها. این امر، وابستگی‌های لایه داخلی به لایه‌های خارجی را از بین می‌برد و اصل وارونگی وابستگی را رعایت می‌کند.
*   **افزایش تست‌پذیری**: با تزریق Mock objects یا Test Doubles می‌توان اینتراکتورهای مورد استفاده را در انزوا تست کرد، بدون اینکه نیازی به پایگاه داده واقعی یا سرویس‌های خارجی باشد.
*   **انعطاف‌پذیری و قابلیت تعویض**: پیاده‌سازی‌های مختلف یک رابط را می‌توان به راحتی بدون تغییر منطق اصلی کسب‌وکار تعویض کرد، به عنوان مثال، تغییر پایگاه داده از MongoDB به SQLite.
</div>

### سوال 6: مدل‌های درخواست (Request Models) و مدل‌های پاسخ (Response Models) چه نقشی در لایه کاربرد ایفا می‌کنند؟

<div dir="rtl" style="text-align: right;">
**پاسخ:** مدل‌های درخواست و مدل‌های پاسخ **اشیاء انتقال داده (DTOs)** هستند که برای مدیریت جریان داده در مرزهای معماری، به ویژه بین لایه‌های بیرونی و هسته برنامه، استفاده می‌شوند.
*   **مدل‌های درخواست**: **داده‌های ورودی را از منابع خارجی (مانند درخواست‌های HTTP) دریافت کرده و اعتبارسنجی و تبدیل آنها را به فرمت مناسبی که موارد استفاده انتظار دارند، انجام می‌دهند**. آنها به عنوان یک ساختار واضح برای داده‌های ورودی عمل کرده و اطمینان می‌دهند که منطق دامنه از جزئیات فرمت‌های خارجی جدا می‌ماند.
*   **مدل‌های پاسخ**: **اشیاء دامنه را به ساختارهایی مناسب برای مصرف خارجی (مانند پاسخ‌های JSON یا نمایش در UI) تبدیل می‌کنند**. آنها دقیقاً کنترل می‌کنند که چه داده‌هایی و با چه فرمتی از دامنه منتشر شوند و یک نقطه یکپارچه برای سریالی‌سازی (serialization) فراهم می‌کنند.

متدهای `to_execution_params()` در مدل‌های درخواست و `from_entity()` در مدل‌های پاسخ به ترتیب جریان داده‌های ورودی و خروجی را تسهیل می‌کنند.
</div>

### سوال 7: مفهوم "پورت‌ها" (Ports) در لایه کاربرد چیست و چگونه به حفظ جداسازی از نگرانی‌های خارجی کمک می‌کند؟

<div dir="rtl" style="text-align: right;">
**پاسخ:** "پورت‌ها" در لایه کاربرد به **رابط‌های انتزاعی** (abstract interfaces) اطلاق می‌شوند که دقیقاً قابلیت‌های مورد نیاز لایه کاربرد از سرویس‌های خارجی (مانند پایگاه‌های داده، سرویس‌های اعلان، یا سیستم‌های پرداخت) را مشخص می‌کنند. این پورت‌ها، منطق اصلی کسب‌وکار را از جزئیات پیاده‌سازی سرویس‌های خارجی جدا نگه می‌دارند.

مثال: `NotificationPort`. لایه کاربرد (Use Cases) به این پورت انتزاعی وابسته است و نه به پیاده‌سازی‌های بتنی آن (مانانند `SendGridNotifier`). این جداسازی تضمین می‌کند که منطق کسب‌وکار از فناوری‌های بیرونی ناآگاه باقی می‌ماند و در نتیجه، تعویض یا به‌روزرسانی سرویس‌های خارجی بدون تأثیر بر هسته برنامه امکان‌پذیر است.
</div>

```python
class NotificationPort(ABC):
    @abstractmethod
    def notify_task_completed(self, task: Task) -> None:
        """Notify when a task is completed"""
        pass
```

<div dir="rtl" style="text-align: right;">

### سوال 8: الگوهای "سرویس‌های اختیاری" (Optional Services) و "آداپتور" (Adapter) چگونه به مدیریت انعطاف‌پذیری و تغییرات در سرویس‌های خارجی در لایه کاربرد کمک می‌کنند؟

<div dir="rtl" style="text-align: right;">
**پاسخ:**
*   **سرویس‌های اختیاری (Optional Services)**: این الگو با استفاده از یک دیکشنری برای نگهداری سرویس‌های اختیاری و اجرای شرطی (e.g., `if analytics := self._optional_services.get('analytics'):`), به شما امکان می‌دهد ویژگی‌ها و سرویس‌هایی را که ممکن است در یک استقرار خاص وجود داشته باشند یا نداشته باشند، به طور تمیز مدیریت کنید. این روش، عملیات اصلی کسب‌وکار را متمرکز و پایدار نگه می‌دارد، در حالی که قابلیت‌های جدید را می‌توان بدون تغییر کد موجود اضافه کرد.
*   **الگوی آداپتور (Adapter Pattern)**: این الگو برای مدیریت سوئیچ کردن بین رابط‌های مختلف سرویس‌های خارجی، به ویژه هنگام ادغام با سرویس‌های شخص ثالث یا مدیریت ارتقاء سیستم، استفاده می‌شود. آداپتورها یک سرویس خارجی با رابط متفاوت را "بسته‌بندی" (wrap) می‌کنند تا با رابط مورد انتظار لایه کاربرد مطابقت داشته باشد، بدون اینکه نیاز به تغییر کد هسته برنامه باشد.
</div>

### سوال 9: برنامه‌ریزی برای تکامل در لایه کاربرد به چه معناست و چه مزایایی برای سیستم دارد؟

<div dir="rtl" style="text-align: right;">
**پاسخ:** برنامه‌ریزی برای تکامل در لایه کاربرد به این معناست که سیستم به گونه‌ای طراحی و پیاده‌سازی شود که بتواند با موفقیت به نیازهای در حال تغییر پاسخ دهد و در طول زمان مقیاس‌پذیر باشد. این شامل پذیرش تغییر به عنوان یک جنبه طبیعی در توسعه نرم‌افزار است.

مزایای برنامه‌ریزی برای تکامل عبارتند از:
*   **انعطاف‌پذیری در پیاده‌سازی**: لایه کاربرد می‌تواند از طریق همان رابط، پیاده‌سازی‌های متنوعی از وابستگی‌ها (مانند مخازن) را بپذیرد.
*   **انعطاف‌پذیری فناوری**: می‌توان فناوری‌های زیربنایی (مانند موتورهای پایگاه داده) را بدون تغییر کد مورد استفاده، تعویض کرد.
*   **مرزهای سازگار**: تغییرات در نسخه‌های API (مثلاً v1 به v2) یا مشتریان مختلف (موبایل، وب، CLI) را می‌توان با استفاده مجدد از همان کد مورد استفاده اساسی، مدیریت کرد.
*   **افزایش اعتماد به نفس در توسعه**: با وجود این ساختار، می‌توان قابلیت‌های جدیدی مانند ادغام Salesforce یا لاگ‌گیری حسابرسی را بدون برهم زدن عملکرد موجود یا به خطر انداختن یکپارچگی معماری اضافه کرد.
</div>

### سوال 10: چگونه لایه کاربرد با اصول SOLID که در فصل 2 معرفی شدند، هماهنگ می‌شود؟

<div dir="rtl" style="text-align: right;">
**پاسخ:** لایه کاربرد به طور طبیعی با اصول SOLID هماهنگ است و آنها را تقویت می‌کند.
*   **اصل مسئولیت یگانه (SRP)**: هر مورد استفاده (use case) یک مسئولیت یگانه و متمرکز برای انجام یک هدف تجاری خاص دارد.
*   **اصل باز-بسته (OCP)**: لایه کاربرد برای افزودن موارد استفاده جدید یا پیاده‌سازی‌های جدید سرویس‌ها باز است، اما برای تغییر کد موجود بسته است.
*   **اصل جایگزینی لیسکوف (LSP)**: از طریق استفاده از رابط‌ها و تزریق وابستگی، پیاده‌سازی‌های بتنی سرویس‌ها (مانند مخازن) می‌توانند جایگزین رابط‌های انتزاعی خود شوند بدون اینکه رفتار سیستم را بشکنند.
*   **اصل جداسازی رابط (ISP)**: لایه کاربرد رابط‌هایی را (پورت‌ها) تعریف می‌کند که به صورت متمرکز و مشتری-محور هستند و تنها قابلیت‌های مورد نیاز را مشخص می‌کنند.
*   **اصل وارونگی وابستگی (DIP)**: لایه کاربرد به انتزاعات (interfaces) وابسته است، نه به پیاده‌سازی‌های بتنی لایه‌های خارجی (Frameworks and Drivers). این امر تضمین می‌کند که منطق کسب‌وکار از جزئیات زیربنایی جدا باقی می‌ماند و مرزهای معماری تمیز حفظ می‌شوند.
</div>
</div>