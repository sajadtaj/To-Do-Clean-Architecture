
<div dir="rtl" style="text-align: right;">

**۱. نقش اصلی لایه موجودیت (Entity Layer) یا همان لایه دامنه (Domain Layer) در معماری پاک، همانطور که در فصل ۴ بحث شده، چیست؟**

**پاسخ:** لایه موجودیت یا دامنه هسته اصلی اپلیکیشن ما را تشکیل می‌دهد و **مفاهیم و قوانین اساسی کسب‌وکار** را در خود محصور می‌کند. این لایه مستقل از دغدغه‌های بیرونی است و **بنیان و اساس** سایر لایه‌های معماری پاک را می‌سازد. تمرکز بر این هسته تضمین می‌کند که اپلیکیشن ما صرف نظر از فناوری‌ها یا فریم‌ورک‌های مورد استفاده در لایه‌های بیرونی، به هدف اصلی خود وفادار بماند.

**۲. چگونه رویکرد طراحی مبتنی بر دامنه (Domain-Driven Design - DDD) معماری پاک را تکمیل می‌کند، طبق فصل ۴؟**

**پاسخ:** در حالی که معماری پاک نقشه ساختاری برای سازماندهی لایه‌های کد فراهم می‌کند ("چه چیزی" را باید ساخت)، **DDD الگوهای تاکتیکی** را برای پیاده‌سازی موثر منطق اصلی کسب‌وکار ارائه می‌دهد ("چگونه" باید ساخت). به عبارت دیگر، DDD تکنیک‌های مدل‌سازی خاصی مانند **موجودیت‌ها (Entities)، اشیاء ارزشی (Value Objects)، و سرویس‌های دامنه (Domain Services)** را ارائه می‌دهد که لایه اصلی کسب‌وکار را پر می‌کنند و به ما در ترجمه الزامات کسب‌وکار به مدل‌های دامنه قوی کمک می‌کند.

**۳. سه مفهوم ساختاری بنیادی DDD که در فصل ۴ مورد بحث قرار گرفته‌اند کدامند و چگونه با لایه موجودیت مرتبط می‌شوند؟**

**پاسخ:** سه مفهوم اصلی عبارتند از:
*   **موجودیت‌ها (Entities):** اشیائی هستند که با **هویت منحصربه‌فرد** خود تعریف می‌شوند و حتی اگر ویژگی‌هایشان تغییر کند، هویتشان ثابت می‌ماند. در معماری پاک، این اشیاء اصلی کسب‌وکار پایدارترین قوانین را در مرکز سیستم تجسم می‌دهند.
*   **اشیاء ارزشی (Value Objects):** اشیاء تغییرناپذیری هستند که با **ویژگی‌هایشان** تعریف می‌شوند، نه هویتشان. آن‌ها رفتارهای منسجم را بدون نیاز به شناسایی منحصربه‌فرد محصور می‌کنند.
*   **سرویس‌های دامنه (Domain Services):** عملیات بی‌استفاده‌ای را نشان می‌دهند که به‌طور طبیعی به یک موجودیت یا شیء ارزشی تعلق ندارند. آن‌ها منطق دامنه را که شامل چندین شیء است، مدیریت می‌کنند.
این سه جزء، **لایه موجودیت (Entity Layer)** را در معماری پاک تشکیل می‌دهند.

**۴. اهمیت "زبان فراگیر (Ubiquitous Language)" در DDD، طبق آنچه در فصل ۴ توضیح داده شده، چیست؟**

**پاسخ:** زبان فراگیر یک **واژگان مشترک و دقیق** است که هم توسط توسعه‌دهندگان و هم توسط کارشناسان دامنه به اشتراک گذاشته می‌شود. این زبان به‌طور مداوم در کد، تست‌ها و مکالمات استفاده می‌شود و به **جلوگیری از سوءتفاهم‌ها** و حفظ همسویی مدل با دامنه کسب‌وکار کمک می‌کند. به عنوان مثال، در یک سیستم مدیریت وظایف، این زبان شامل اصطلاحاتی مانند "وظیفه"، "پروژه"، "تاریخ سررسید"، "اولویت" و "وضعیت" می‌شود.

**۵. چگونه از کلاس‌های داده (dataclasses) پایتون در فصل ۴ برای پیاده‌سازی موجودیت‌های دامنه مانند `Task` استفاده می‌شود؟**

**پاسخ:** کلاس‌های داده پایتون (معرفی شده در پایتون ۳.۷) راهی مختصر برای ایجاد کلاس‌هایی ارائه می‌دهند که عمدتاً داده‌ها را ذخیره می‌کنند اما می‌توانند رفتار نیز داشته باشند. آن‌ها به‌طور خودکار متدهای خاصی مانند `__init__()`، `__repr__()` و `__eq__()` را تولید می‌کنند و **کد تکراری (boilerplate)** را کاهش می‌دهند. این ویژگی به ایجاد موجودیت‌های واضح و متمرکز که داده‌ها و رفتار را محصور می‌کنند، کمک می‌کند.

```python
from dataclasses import dataclass, field
from uuid import UUID, uuid4

@dataclass
class Entity:
    id: UUID = field(default_factory=uuid4, init=False)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return NotImplemented
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)
```

**۶. چرا محصور کردن قوانین کسب‌وکار در موجودیت‌ها، همانطور که با موجودیت `Task` در فصل ۴ نشان داده شده است، بسیار مهم است؟**

**پاسخ:** محصور کردن قوانین کسب‌وکار (که اغلب **ناورداها (invariants)** نامیده می‌شوند) در داخل موجودیت‌ها برای اطمینان از اینکه موجودیت همیشه در یک **حالت معتبر** باقی می‌ماند، حیاتی است. این کار باعث می‌شود کد **قابل نگهداری‌تر و قابل انطباق‌تر** باشد، زیرا قوانین مربوط به موجودیت مستقیماً در کنار آن تعریف و اجرا می‌شوند، صرف نظر از اینکه چگونه در اپلیکیشن استفاده می‌شود.

**۷. اشیاء ارزشی (Value Objects) چه هستند و چه مزایای کلیدی را پیاده‌سازی آن‌ها (مانند `TaskStatus`، `Priority`، `Deadline`) در معماری پاک، طبق فصل ۴، فراهم می‌کند؟**

**پاسخ:** اشیاء ارزشی اشیاء تغییرناپذیری هستند که با ویژگی‌هایشان تعریف می‌شوند، نه هویتشان. مزایای کلیدی آن‌ها در معماری پاک شامل:
*   **تغییرناپذیری (Immutability):** حالت آن‌ها پس از ایجاد قابل تغییر نیست، که به جلوگیری از باگ‌ها کمک می‌کند.
*   **برابری مبتنی بر ویژگی‌ها (Equality based on attributes):** دو شیء ارزشی با ویژگی‌های یکسان، برابر در نظر گرفته می‌شوند.
*   **محصور کردن مفاهیم دامنه (Encapsulation of domain concepts):** ایده‌های دامنه را به عنوان "شهروندان درجه اول" در کد ما نشان می‌دهند، که گویایی را بهبود می‌بخشد.
*   **جلوگیری از وسواس نسبت به انواع اولیه (Prevention of primitive obsession):** استفاده از انواع اولیه را برای نمایش مفاهیم دامنه، با افزودن معنای معنایی و ایمنی نوع، جایگزین می‌کنند.
*   **آزمایش‌پذیری ساده (Simplified testing):** ایجاد و استفاده از آن‌ها در تست‌ها آسان است.

**۸. نقش "سرویس دامنه (Domain Service)" در فصل ۴ چیست و چه زمانی استفاده از آن مناسب است؟**

**پاسخ:** سرویس دامنه منطق مربوط به **عملیات پیچیده‌ای** را که به‌طور طبیعی به یک موجودیت یا شیء ارزشی واحد تعلق ندارند، محصور می‌کند. آن‌ها عملیات بی‌استفاده‌ای را انجام می‌دهند که ممکن است چندین شیء را در بر بگیرند، مانند **محاسبه اولویت یک وظیفه** بر اساس عوامل مختلف. این سرویس‌ها موجودیت‌ها و اشیاء ارزشی را متمرکز و منسجم نگه می‌دارند.

**۹. چگونه "مجموعه‌ها (Aggregates)" (مانند `Project` در فصل ۴) مدل دامنه را بهبود می‌بخشند و هدف اصلی آن‌ها چیست؟**

**پاسخ:** مجموعه‌ها **مجموعه‌ای از موجودیت‌ها و اشیاء ارزشی مرتبط** را تحت یک ریشه واحد (مانند `Project` برای `Task`ها) گروه بندی می‌کنند. هدف اصلی آن‌ها **تضمین ثبات و یکپارچگی مجموعه** به عنوان یک واحد معاملاتی است. عملیاتی که بر چندین وظیفه در یک پروژه تأثیر می‌گذارند (مانند علامت‌گذاری همه به عنوان تکمیل شده) باید از طریق ریشه مجموعه انجام شود تا **ثبات حفظ شود**.

```python
# TodoApp/todo_app/domain/entities/project.py
from dataclasses import dataclass, field
from typing import Optional
from uuid import UUID
from .task import Task # Assuming Task entity is in the same domain folder
from ..entities.base_entity import Entity # Assuming base_entity is defined

@dataclass
class Project(Entity):
    name: str
    description: str = ""
    _tasks: dict[UUID, Task] = field(default_factory=dict, init=False)

    def add_task(self, task: Task) -> None:
        self._tasks[task.id] = task

    def remove_task(self, task_id: UUID) -> None:
        self._tasks.pop(task_id, None)

    def get_task(self, task_id: UUID) -> Optional[Task]:
        return self._tasks.get(task_id)

    @property
    def tasks(self) -> list[Task]:
        return list(self._tasks.values())
```

**۱۰. "قانون وابستگی (Dependency Rule)" در معماری پاک چیست و فصل ۴ چگونه بر اهمیت آن برای استقلال دامنه تأکید می‌کند؟**

**پاسخ:** قانون وابستگی بیان می‌کند که **وابستگی‌های کد منبع باید فقط به سمت داخل، به سمت سیاست‌های سطح بالاتر (لایه‌های داخلی‌تر) اشاره کنند**. لایه‌های داخلی چیزی درباره لایه‌های بیرونی نمی‌دانند، در حالی که لایه‌های بیرونی باید به لایه‌های داخلی وابسته باشند و با آن‌ها سازگار شوند. فصل ۴ بر این تأکید می‌کند که این قانون تضمین می‌کند که **منطق اصلی کسب‌وکار خالص و بدون تأثیر از عوامل خارجی** مانند پایگاه‌های داده یا رابط کاربری باقی می‌ماند. این جداسازی **آزمایش‌پذیری و انعطاف‌پذیری** سیستم را به‌طور قابل توجهی افزایش می‌دهد.

</div>