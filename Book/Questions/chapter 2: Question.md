<div dir="rtl" style="text-align: right;">

**۱. اصول SOLID چه هستند و چرا در توسعه نرم‌افزار، به ویژه برای معماری تمیز (Clean Architecture)، اهمیت دارند؟**

**پاسخ**: اصول **SOLID** مجموعه‌ای از پنج اصل کلیدی برای برنامه‌نویسی شیءگرا و طراحی نرم‌افزار هستند که به توسعه‌دهندگان کمک می‌کنند تا ساختارهای نرم‌افزاری **قابل فهم‌تر، منعطف‌تر و قابل نگهداری‌تری** ایجاد کنند. این اصول **پایه و اساس معماری تمیز** (Clean Architecture) را تشکیل می‌دهند و به ایجاد مؤلفه‌هایی با **کوپلینگ پایین (loosely coupled)** و **انسجام بالا (highly cohesive)** کمک می‌کنند که آزمایش، تغییر و توسعه آن‌ها آسان‌تر است.

**۲. اصل مسئولیت واحد (Single Responsibility Principle - SRP) را توضیح داده و مثالی از کاربرد آن در پایتون ارائه دهید.**

**پاسخ**: اصل **SRP** بیان می‌کند که هر ماژول نرم‌افزاری باید **فقط و فقط یک دلیل برای تغییر** داشته باشد. این بدان معناست که یک کلاس یا تابع باید متمرکز بر یک وظیفه خاص باشد.
*   **مثال نقض SRP**: در یک طراحی نامناسب، یک کلاس `User` ممکن است شامل متدهایی برای `create_post` (ایجاد پست)، `get_timeline` (دریافت تایم‌لاین) و `update_profile` (به‌روزرسانی پروفایل) باشد. این کلاس چندین دلیل برای تغییر دارد، مثلاً تغییر در منطق پست‌ها یا منطق تایم‌لاین هر دو باعث تغییر در کلاس `User` می‌شوند.
*   **مثال رعایت SRP**: برای رعایت SRP، کلاس `User` تنها به مدیریت داده‌های اصلی کاربر (user data) محدود می‌شود و مسئولیت‌های دیگر به کلاس‌های جداگانه منتقل می‌شوند؛ مانند `PostManager` برای ایجاد پست، `TimelineService` برای مدیریت تایم‌لاین، و `ProfileManager` برای به‌روزرسانی پروفایل. این تفکیک، **قابلیت نگهداری و تست‌پذیری** کد را به شدت افزایش می‌دهد.

**۳. اصل باز-بسته (Open–Closed Principle - OCP) چیست و چگونه به ایجاد سیستم‌های قابل توسعه در پایتون کمک می‌کند؟**

**پاسخ**: اصل **OCP** بیان می‌کند که یک موجودیت نرم‌افزاری باید برای **توسعه باز** باشد، اما برای **تغییر بسته** باشد. یعنی باید بتوانیم قابلیت‌های جدیدی را بدون تغییر کد موجود و تست‌شده اضافه کنیم.
*   **ترویج سیستم‌های قابل توسعه**: این اصل با استفاده از **انتزاع‌ها (abstractions)** (مانند کلاس‌های انتزاعی یا اینترفیس‌ها) به جای پیاده‌سازی‌های بتنی (concrete implementations) عمل می‌کند.
*   **مثال**: در یک ماشین حساب مساحت، بجای اینکه کلاس `AreaCalculator` شامل منطق شرطی برای هر نوع شکل (`if isinstance(shape, Rectangle):`) باشد که با اضافه شدن هر شکل جدید باید تغییر کند، می‌توان یک کلاس انتزاعی `Shape` با متد `area()` تعریف کرد. سپس هر شکل (مانند `Rectangle`, `Circle`, `Triangle`) از `Shape` ارث‌بری کرده و متد `area()` خود را پیاده‌سازی می‌کند. حالا `AreaCalculator` فقط به انتزاع `Shape` وابسته است و می‌تواند مساحت هر شکلی را محاسبه کند، بدون نیاز به تغییر در خودش.

**۴. اصل تفکیک اینترفیس (Interface Segregation Principle - ISP) را شرح داده و توضیح دهید چرا برای طراحی اینترفیس‌های منعطف در پایتون حیاتی است.**

**پاسخ**: اصل **ISP** ما را راهنمایی می‌کند تا **اینترفیس‌های کوچک، خاص‌منظوره و متمرکز** را طراحی کنیم که نیازهای دقیق مشتریان خود را برآورده سازند.
*   **اهمیت**: این اصل از اینترفیس‌های "چاق" و یکپارچه که کلاس‌ها را مجبور به پیاده‌سازی متدهایی می‌کنند که برای آن‌ها بی‌ربط هستند، جلوگیری می‌کند.
*   **مثال**: در یک سیستم پخش چندرسانه‌ای، بجای یک اینترفیس بزرگ `MultimediaPlayer` که متدهایی مانند `display_lyrics` (نمایش متن ترانه) و `apply_video_filter` (اعمال فیلتر ویدیو) را هم شامل می‌شد، می‌توانیم اینترفیس‌ها را به بخش‌های کوچکتر تقسیم کنیم: `MediaPlayable` (قابل پخش رسانه)، `LyricsDisplayable` (قابل نمایش متن ترانه) و `VideoFilterable` (قابل اعمال فیلتر ویدیو). حالا یک `MusicPlayer` (پخش‌کننده موسیقی) فقط `MediaPlayable` و `LyricsDisplayable` را پیاده‌سازی می‌کند و نیازی به `VideoFilterable` ندارد.
*   **مزایا**: ISP به **کاهش کوپلینگ**، **بهبود قابلیت نگهداری** و **افزایش انعطاف‌پذیری** کمک می‌کند.

**۵. اصل جایگزینی لیسکوف (Liskov Substitution Principle - LSP) چیست و چه مزایایی در سلسله‌مراتب وراثت دارد؟**

**پاسخ**: اصل **LSP** بیان می‌کند که **زیرکلاس‌ها (subclasses) باید بتوانند جایگزین سوپرکلاس‌های (base classes) خود شوند بدون اینکه رفتار برنامه را نقض کنند**. این اصل به حفظ "قرارداد" (contract) تعریف‌شده توسط کلاس پایه در سراسر سلسله‌مراتب وراثت کمک می‌کند.
*   **مثال نقض LSP**: اگر کلاس `ElectricCar` از کلاس `Vehicle` (وسیله نقلیه سوخت‌سوز) ارث‌بری کند و متد `consume_fuel` را به گونه‌ای تغییر دهد که مفهوم "مصرف سوخت" (لیتر) را به "مصرف انرژی" (kWh) تبدیل کند، این LSP را نقض می‌کند؛ زیرا تابعی که با `Vehicle` کار می‌کند، با `ElectricCar` به درستی عمل نخواهد کرد.
*   **مثال رعایت LSP**: برای رعایت LSP، می‌توان یک انتزاع سطح بالاتر مانند `PowerSource` (منبع انرژی) تعریف کرد که هم `FuelTank` (باک سوخت) و هم `Battery` (باتری) آن را پیاده‌سازی کنند. حالا کلاس `Vehicle` به `PowerSource` وابسته است، نه به یک نوع خاص از منبع انرژی، و هر دو `FuelTank` و `Battery` می‌توانند جایگزین `PowerSource` شوند.
*   **مزایا**: LSP منجر به **قابلیت پیش‌بینی**، **انعطاف‌پذیری** و **قابلیت توسعه‌پذیری** بهتر سیستم می‌شود.

**۶. اصل وارونگی وابستگی (Dependency Inversion Principle - DIP) را توضیح داده و اهمیت آن را برای معماری تمیز شرح دهید.**

**پاسخ**: اصل **DIP** یکی از مهمترین اصول SOLID برای معماری تمیز است. این اصل بیان می‌کند که:
*   **ماژول‌های سطح بالا (high-level modules) نباید به ماژول‌های سطح پایین (low-level modules) وابسته باشند. هر دو باید به انتزاع‌ها (abstractions) وابسته باشند.**
*   **انتزاع‌ها نباید به جزئیات (details) وابسته باشند. جزئیات باید به انتزاع‌ها وابسته باشند.**
*   **اهمیت برای معماری تمیز**: DIP یک رویکرد عملی برای پیاده‌سازی **قانون وابستگی (Dependency Rule)** معماری تمیز ارائه می‌دهد. این قانون حکم می‌کند که وابستگی‌های کد منبع باید همیشه به سمت لایه‌های داخلی‌تر و با ثبات‌تر (انتزاع‌ها) باشند. با استفاده از DIP، منطق کسب‌وکار اصلی (لایه‌های داخلی) از جزئیات پیاده‌سازی (لایه‌های بیرونی) جدا می‌ماند.
*   **مثال**: بجای اینکه یک `UserEntity` مستقیماً به `MySQLDatabase` (یک پیاده‌سازی خاص) وابسته باشد، می‌توان یک اینترفیس انتزاعی `DatabaseInterface` تعریف کرد. سپس `UserEntity` به این اینترفیس وابسته می‌شود و پیاده‌سازی‌های بتنی مانند `MySQLDatabase` یا `PostgreSQLDatabase` این اینترفیس را پیاده‌سازی می‌کنند. این وارونگی وابستگی، **انعطاف‌پذیری و تست‌پذیری** سیستم را به شدت افزایش می‌دهد.

**۷. اصول SOLID چگونه به اهداف معماری تمیز کمک می‌کنند؟**

**پاسخ**: اصول SOLID پایه‌ای قوی برای ساخت سیستم‌های مطابق با معماری تمیز فراهم می‌کنند:
*   **SRP (مسئولیت واحد)**: به تفکیک مسئولیت‌ها کمک می‌کند و مؤلفه‌های متمرکز و با انسجام بالا ایجاد می‌کند، که برای حفظ **مرزهای تمیز** در معماری تمیز ضروری است.
*   **OCP (باز-بسته)**: امکان **توسعه‌پذیری** سیستم را بدون تغییر کد موجود فراهم می‌آورد. این به معنای **پایداری لایه‌های داخلی** (Domain و Application) معماری تمیز است که نیازی به تغییر با اضافه شدن قابلیت‌های جدید بیرونی ندارند.
*   **ISP (تفکیک اینترفیس)**: با تشویق به استفاده از **اینترفیس‌های کوچک و خاص‌منظوره**، به تعریف مرزهای دقیق بین لایه‌ها و کاهش وابستگی‌های غیرضروری کمک می‌کند.
*   **LSP (جایگزینی لیسکوف)**: تضمین می‌کند که **انتزاع‌ها صحیح و قابل اطمینان** هستند و زیرکلاس‌ها می‌توانند بدون نقض رفتار جایگزین سوپرکلاس‌ها شوند. این امر برای حفظ **انعطاف‌پذیری و قابل اطمینان بودن** سیستم‌های مبتنی بر انتزاع در معماری تمیز حیاتی است.
*   **DIP (وارونگی وابستگی)**: **مستقیماً قانون وابستگی معماری تمیز را پیاده‌سازی می‌کند**. با وارونه کردن وابستگی‌ها به گونه‌ای که لایه‌های سطح بالا به انتزاع‌ها وابسته باشند، تضمین می‌کند که منطق کسب‌وکار از جزئیات پیاده‌سازی خارجی **جدا و محافظت‌شده** باقی می‌ماند.

**۸. مفهوم "دلیل برای تغییر" در SRP چیست و چرا تعادل در اعمال SRP مهم است؟**

**پاسخ**: مفهوم "دلیل برای تغییر" (reason to change) در **SRP** به این معنی است که یک ماژول یا کلاس باید تنها **یک ذی‌نفع یا گروه ذی‌نفع** داشته باشد که خواستار تغییر آن شود. این کمک می‌کند تا تغییر در یک جنبه از کسب‌وکار، تنها بر بخش مربوطه از کد تأثیر بگذارد.
*   **اهمیت تعادل**: اگرچه SRP بسیار مهم است، اما **اعمال بیش از حد آن می‌تواند منجر به ایجاد تعداد زیادی کلاس و تابع بسیار کوچک و بیش از حد جزئی (granular) شود**. این امر می‌تواند درک و پیمایش کلی سیستم را دشوارتر کند و به جای ساده‌سازی، پیچیدگی غیرضروری ایجاد کند. هدف SRP بهبود قابلیت نگهداری و فهم کد است، نه صرفاً شکستن آن به کوچکترین واحدها.

**۹. ماژول `abc` پایتون و ویژگی `Protocol` آن چگونه از OCP و ISP پشتیبانی می‌کنند؟**

**پاسخ**:
*   **پشتیبانی از OCP (باز-بسته)**: هر دو `abc` (Abstract Base Classes) و `Protocol` (معرفی شده در Python 3.8) به پیاده‌سازی OCP کمک می‌کنند. آن‌ها به شما اجازه می‌دهند **اینترفیس‌های انتزاعی** تعریف کنید که کلاس‌های دیگر می‌توانند آن‌ها را پیاده‌سازی کنند. با تعریف این اینترفیس‌ها، می‌توانید قابلیت‌های جدید را با اضافه کردن کلاس‌های جدیدی که اینترفیس را پیاده‌سازی می‌کنند، به سیستم اضافه کنید، بدون اینکه نیازی به تغییر کد موجود و وابسته به آن اینترفیس باشد.
*   **پشتیبانی از ISP (تفکیک اینترفیس)**: هر دو ابزار به طراحی **اینترفیس‌های کوچک و متمرکز** کمک می‌کنند. بجای یک اینترفیس بزرگ، می‌توانید چندین اینترفیس کوچک را تعریف کنید که هر کدام یک مجموعه متدهای خاص را پوشش می‌دهند. این به کلاس‌ها اجازه می‌دهد تا تنها اینترفیس‌هایی را که واقعاً به آن‌ها نیاز دارند، پیاده‌سازی کنند، که از **وابستگی‌های غیرضروری و پیاده‌سازی متدهای بی‌ربط** جلوگیری می‌کند. `Protocol` به طور خاص، انعطاف‌پذیری تایپ داک (duck typing) را با مزایای Type Hinting ترکیب می‌کند، که به طور طبیعی با تأکید معماری تمیز بر کوپلینگ سست همسو است.

**۱۰. اصل وارونگی وابستگی (DIP) چگونه با قانون وابستگی (Dependency Rule) در معماری تمیز مرتبط است؟**

**پاسخ**: اصل **DIP** نقش **بسیار مهمی** در پیاده‌سازی **قانون وابستگی** در معماری تمیز دارد و در واقع **ستون فقرات** آن است.
*   **قانون وابستگی**: این قانون اساسی معماری تمیز بیان می‌کند که **وابستگی‌های کد منبع باید همیشه به سمت داخل (به سمت لایه‌های داخلی‌تر و پایدارتر)** اشاره کنند. به عبارت دیگر، لایه‌های بیرونی باید به لایه‌های داخلی وابسته باشند، اما لایه‌های داخلی نباید هیچ اطلاعی از لایه‌های بیرونی داشته باشند.
*   **ارتباط با DIP**: DIP یک **استراتژی مشخص برای اعمال این قانون** ارائه می‌دهد. طبق DIP، ماژول‌های سطح بالا (مانند منطق کسب‌وکار در لایه‌های Domain و Application) و ماژول‌های سطح پایین (مانند پایگاه داده یا UI در لایه Frameworks and Drivers) هر دو باید به **انتزاع‌ها (abstractions)** وابسته باشند. این بدان معنی است که **لایه‌های داخلی (انتزاع‌ها) اینترفیس‌هایی را تعریف می‌کنند** که لایه‌های بیرونی آن‌ها را پیاده‌سازی می‌کنند. این **وارونگی جهت وابستگی** تضمین می‌کند که تغییرات در جزئیات خارجی (مانند تغییر فریم‌ورک وب یا پایگاه داده) بر منطق کسب‌وکار اصلی تأثیری نمی‌گذارند.