<div dir="rtl" style="text-align: right;">

**فصل ۶: لایه آداپتورهای واسط (Interface Adapters): کنترلرها و پرزنترها**

در فصل‌های ۴ و ۵، هسته سیستم مدیریت وظایف خود را ساختیم — موجودیت‌های دامین که مفاهیم کسب‌وکار ما را نشان می‌دهند و موارد استفاده (use cases) که آن‌ها را سازماندهی می‌کنند. مدل‌های درخواست/پاسخ لایه کاربرد (Application layer) مسئول ترجمه بین موارد استفاده و موجودیت‌های دامین هستند و تضمین می‌کنند که قوانین اصلی کسب‌وکار ما **خالص** و **متمرکز** باقی بمانند. با این حال، هنوز یک شکاف بین این موارد استفاده و دنیای بیرون، مانند واسط‌های وب یا ابزارهای خط فرمان (CLI) وجود دارد. اینجاست که لایه **آداپتورهای واسط (Interface Adapters)** وارد عمل می‌شود.

لایه آداپتورهای واسط به عنوان مترجم بین هسته برنامه ما و **مسائل خارجی** عمل می‌کند. این لایه داده‌ها را بین فرمت‌های مناسب برای آژانس‌های خارجی و فرمت‌های مورد انتظار موارد استفاده ما تبدیل می‌کند. از طریق کنترلرها (controllers) و پرزنترهای (presenters) با دقت طراحی‌شده، این لایه **مرزهای معماری** را حفظ می‌کند که قوانین اصلی کسب‌وکار ما را **ایزوله** و **قابل نگهداری** نگه می‌دارد.

در این فصل، چگونگی پیاده‌سازی لایه آداپتورهای واسط در پایتون را بررسی خواهیم کرد و نشان می‌دهیم که چگونه این لایه **قانون وابستگی (Dependency Rule)** معماری پاک را رعایت می‌کند. خواهید آموخت که چگونه کنترلرها ورودی خارجی را با موارد استفاده ما هماهنگ می‌کنند و چگونه پرزنترها داده‌های دامین را برای نیازهای خروجی مختلف تبدیل می‌کنند. در پایان این فصل، درک خواهید کرد که چگونه یک لایه آداپتورهای واسط **انعطاف‌پذیر** ایجاد کنید که **منطق اصلی کسب‌وکار شما را محافظت می‌کند** در حالی که چندین واسط را پشتیبانی می‌کند. شما مرزهای معماری پاکی را پیاده‌سازی خواهید کرد که سیستم شما را **قابل نگهداری‌تر** و **قابل انطباق‌تر** با تغییرات می‌کند.

<div dir="rtl" style="text-align: right;">

### نیازمندی‌های فنی

مثال‌های کد ارائه شده در این فصل و در طول باب، با پایتون ۳.۱۳ آزمایش شده‌اند. برای اختصار، بیشتر مثال‌های کد در این فصل تنها تا حدی پیاده‌سازی شده‌اند. نسخه‌های کامل همه مثال‌ها را می‌توانید در مخزن گیت‌هاب همراه کتاب بیابید.

### طراحی لایه آداپتورهای واسط

در معماری پاک، هر لایه هدف خاصی را در حفظ **جدایی نگرانی‌ها (separation of concerns)** دنبال می‌کند. همانطور که در فصل‌های قبل دیدیم، لایه دامین (Domain layer) قوانین اصلی کسب‌وکار ما را کپسوله می‌کند، در حالی که لایه کاربرد (Application layer) موارد استفاده را سازماندهی می‌کند. اما چگونه این لایه‌های متمرکز بر کسب‌وکار را به نیازهای عملی واسط‌های کاربری، پایگاه‌های داده و سرویس‌های خارجی متصل کنیم؟ این نقش لایه آداپتورهای واسط است.

محل دیاگرام 6.1

<div dir="rtl" style="text-align: right;">

**شکل ۶.۱: لایه آداپتورهای واسط با اجزای اصلی**

در بخش بعدی، به جزئیات نقش لایه آداپتورهای واسط می‌پردازیم و مثال‌هایی از این لایه را در برنامه مدیریت وظایف خود مشاهده خواهیم کرد.

#### نقش لایه آداپتورهای واسط در معماری پاک

لایه آداپتورهای واسط به عنوان مجموعه‌ای از مترجم‌ها بین هسته برنامه ما و جزئیات خارجی مانند یک چارچوب وب یا یک واسط خط فرمان عمل می‌کند. این لایه **بسیار مهم** است زیرا به ما امکان می‌دهد **مرزهای معماری پاک** را حفظ کنیم در حالی که تعامل عملی با نگرانی‌های خارجی را امکان‌پذیر می‌سازد. با قرار گرفتن بین لایه کاربرد و واسط‌های خارجی، تضمین می‌کند که:

*   منطق اصلی کسب‌وکار ما خالص و متمرکز باقی می‌ماند.
*   نگرانی‌های خارجی نمی‌توانند به لایه‌های داخلی نفوذ کنند.
*   تغییرات در واسط‌های خارجی بر منطق اصلی ما تأثیر نمی‌گذارد.
*   چندین واسط می‌توانند به طور مداوم با سیستم ما تعامل داشته باشند.

اصل کلیدی حاکم بر این لایه، **قانون وابستگی (Dependency Rule)** است: وابستگی‌ها باید به سمت داخل، به سمت قوانین اصلی کسب‌وکار اشاره کنند. لایه آداپتورهای واسط این قانون را به شدت با تضمین اینکه همه ترجمه‌ها مرزهای معماری مناسب را حفظ می‌کنند، اجرا می‌کند.

#### مسئولیت‌های لایه آداپتورهای واسط

همانطور که عمیق‌تر به لایه آداپتورهای واسط در معماری پاک می‌پردازیم، درک مسئولیت‌های اصلی آن ضروری است. همانطور که یک مترجم باید به هر دو زبانی که با آنها کار می‌کند مسلط باشد، این لایه نیز باید هم زبان دقیق هسته برنامه ما و هم لهجه‌های متنوع واسط‌های خارجی را درک کند. این مسئولیت‌ها دو جریان داده **متمایز اما مکمل** را در سیستم ما تشکیل می‌دهند که هر یک برای حفظ مرزهای معماری ما نیاز به **مدیریت دقیق** دارند.

محل دیاگرام 6.2

<div dir="rtl" style="text-align: right;">

**شکل ۶.۲: جریان داده دوطرفه از طریق لایه آداپتورهای واسط**

در شکل ۶.۲، می‌بینیم که لایه آداپتورهای واسط **جریان داده دوطرفه** بین هسته برنامه ما و نگرانی‌های خارجی را مدیریت می‌کند:

*   **جریان داده ورودی:**
    *   **تبدیل درخواست‌های خارجی** به فرمت‌های خاص برنامه.
    *   **تضمین مطابقت داده‌ها** با الزامات برنامه.
    *   **هماهنگی با موارد استفاده** برای اجرای عملیات.
*   **جریان داده خروجی:**
    *   **تبدیل نتایج برنامه** برای مصرف خارجی.
    *   **ارائه فرمت‌های داده مناسب واسط**.
    *   **حفظ جدایی** بین منطق اصلی و واسط‌های خارجی.

این مسئولیت‌ها پایه و اساس اجزای خاصی را تشکیل می‌دهند که در ادامه بررسی خواهیم کرد.

#### مرزهای لایه آداپتورهای واسط در مقابل لایه کاربرد

هنگام کار با معماری پاک، معمول است که در مورد تمایز بین تبدیل داده‌ها در لایه آداپتورهای واسط در مقابل لایه کاربرد تعجب کنیم. به هر حال، هر دو لایه به نظر می‌رسد که تبدیل داده‌ها را انجام می‌دهند. با این حال، این لایه‌ها در معماری ما اهداف اساسی متفاوتی را دنبال می‌کنند و درک این تفاوت‌ها برای حفظ مرزهای پاک در سیستم ما بسیار مهم است.

در حالی که هر دو لایه آداپتورهای واسط و لایه کاربرد تبدیل داده‌ها را انجام می‌دهند، آنها اهداف متفاوتی را دنبال می‌کنند و مرزهای متفاوتی را حفظ می‌کنند:

*   **لایه کاربرد:**
    *   بین موجودیت‌های دامین و فرمت‌های خاص مورد استفاده تبدیل می‌کند.
    *   بر **هماهنگی قوانین کسب‌وکار** تمرکز دارد.
    *   با انواع و ساختارهای خاص دامین کار می‌کند.
*   **لایه آداپتورهای واسط:**
    *   بین فرمت‌های مورد استفاده و نیازهای واسط خارجی تبدیل می‌کند.
    *   بر **هماهنگی واسط خارجی** تمرکز دارد.
    *   با فرمت‌های خاص واسط و انواع اولیه کار می‌کند.

این جدایی واضح تضمین می‌کند که سیستم ما **مرزهای قوی** بین هسته خود و زمینه خارجی حفظ می‌کند.

#### اجزای کلیدی و روابط آن‌ها

لایه آداپتورهای واسط مسئولیت‌های خود را از طریق سه جزء کلیدی پیاده‌سازی می‌کند:

*   **کنترلرها (Controllers):** جریان ورودی را مدیریت می‌کنند و به عنوان نقاط ورودی برای درخواست‌های خارجی به سیستم ما عمل می‌کنند. آنها تضمین می‌کنند که داده‌های ورودی به هسته برنامه ما الزامات سیستم ما را برآورده می‌کنند در حالی که موارد استفاده ما را از نگرانی‌های خارجی محافظت می‌کنند.
*   **پرزنترها (Presenters):** جریان خروجی را مدیریت می‌کنند و نتایج موارد استفاده را به فرمت‌های مناسب برای مصرف خارجی تبدیل می‌کنند. لایه آداپتورهای واسط واسط‌های پرزنتر را تعریف می‌کند و قراردادی را ایجاد می‌کند که هم موارد استفاده و هم پیاده‌سازی‌های پرزنترهای واقعی باید از آن پیروی کنند.
*   **مدل‌های نمایش (View models):** به عنوان حامل‌های داده بین پرزنترها و نماها (views) عمل می‌کنند و تنها شامل انواع اولیه (primitive types) و ساختارهای داده ساده هستند. این سادگی تضمین می‌کند که نماها می‌توانند به راحتی داده‌های فرمت‌شده را مصرف کنند در حالی که مرزهای معماری پاک را حفظ می‌کنند.

این اجزا در یک جریان با دقت سازماندهی‌شده تعامل دارند که همیشه قانون وابستگی را رعایت می‌کند:

1.  درخواست‌های خارجی از طریق کنترلرها جریان می‌یابند.
2.  کنترلرها با موارد استفاده هماهنگ می‌شوند.
3.  موارد استفاده نتایج را از طریق واسط‌های تعریف‌شده برمی‌گردانند.
4.  پرزنترها نتایج را به مدل‌های نمایش فرمت می‌کنند.
5.  نماها داده‌های فرمت‌شده را مصرف می‌کنند.

این تعامل با دقت سازماندهی‌شده تضمین می‌کند که سیستم ما مرزهای پاک را حفظ می‌کند در حالی که عملی و قابل نگهداری باقی می‌ماند.

#### اصول طراحی واسط

هنگام طراحی واسط‌ها در لایه آداپتورهای واسط، باید مرزهای معماری پاک را با ملاحظات پیاده‌سازی عملی متعادل کنیم. همانطور که در فصل ۵ با مدل‌های درخواست/پاسخ دیدیم، طراحی دقیق واسط جریان روان داده‌ها را امکان‌پذیر می‌کند در حالی که جدایی مناسب بین لایه‌ها را حفظ می‌کند. اصول راهنمای طراحی واسط در این لایه به ما کمک می‌کند تا این تعادل را حفظ کنیم در حالی که به اصول اصلی معماری پاک پایبند هستیم.

سه اصل کلیدی طراحی واسط ما را شکل می‌دهند:

*   **قانون وابستگی** در تمام تصمیمات طراحی اولویت دارد. تمام وابستگی‌ها باید به سمت داخل، به سمت موارد استفاده و موجودیت‌ها اشاره کنند. این بدان معناست که آداپتورهای واسط ما به واسط‌های کاربردی (مانند `CreateTaskUseCase` که در فصل ۵ دیدیم) وابسته هستند، اما واسط‌های کاربردی هرگز به آداپتورهای واسط وابسته نیستند.
*   واسط‌ها باید **فریم‌ورک‌ناشناس** باشند. آنها هرگز نباید به جزئیات خاص فریم‌ورک‌های وب مانند فلاسک (Flask) یا فست‌اِی‌پی‌آی (FastAPI) اشاره کنند. این تضمین می‌کند که منطق اصلی کسب‌وکار ما مستقل از فریم‌ورک باقی می‌ماند و ما می‌توانیم **فریم‌ورک‌های رابط کاربری را بدون تغییر هسته برنامه خود تغییر دهیم**. به عنوان مثال، یک پرزنتر باید بداند چگونه داده‌های وظیفه را برای نمایش فرمت کند، اما نباید بداند که آیا این کار را برای یک صفحه وب، یک واسط خط فرمان یا یک برنامه موبایل انجام می‌دهد.
*   **اصل تفکیک واسط (Interface Segregation Principle)** تضمین می‌کند که واسط‌های ما متمرکز و منسجم باقی می‌مانند. به جای ایجاد واسط‌های بزرگ و یکپارچه، واسط‌های کوچک و هدفمند طراحی می‌کنیم که نیازهای دقیق مشتریان خود را برآورده می‌کنند. به عنوان مثال، به جای یک واسط بزرگ `TaskOperations`، ممکن است واسط‌های جداگانه‌ای برای ایجاد وظیفه، تکمیل و پرس‌وجو داشته باشیم. این جزئی‌نگری انعطاف‌پذیری را فراهم می‌کند و سیستم ما را با تغییرات قابل انطباق‌تر می‌کند.

با پیروی از این اصول، واسط‌هایی ایجاد می‌کنیم که به طور موثر شکاف بین منطق اصلی کسب‌وکار پاک و متمرکز ما و نیازهای عملی واسط‌های خارجی را پر می‌کنند. همانطور که در بخش‌های بعدی پیاده‌سازی‌های خاص را بررسی می‌کنیم، خواهیم دید که چگونه این اصول تصمیمات طراحی ما را هدایت می‌کنند و به کدهای قابل نگهداری‌تر منجر می‌شوند.

### پیاده‌سازی کنترلرها در پایتون

پس از ایجاد پایه‌های نظری لایه آداپتورهای واسط، اکنون به پیاده‌سازی عملی با استفاده از پایتون می‌پردازیم. ویژگی‌های زبان پایتون چندین مکانیزم زیبا برای پیاده‌سازی الگوهای کنترلر معماری پاک ارائه می‌دهند. از طریق کلاس‌های داده (data classes)، کلاس‌های پایه انتزاعی (ABCs) و راهنمایی‌های نوع (type hints)، می‌توانیم مرزهای واسطی واضح و قابل نگهداری ایجاد کنیم در حالی که کد ما پایتونیک باقی می‌ماند.

در حالی که معماری پاک مجموعه‌ای از اصول و الگوها را ارائه می‌دهد، رویکرد پیاده‌سازی سفت و سختی را تجویز نمی‌کند. همانطور که ادامه می‌دهیم، به یاد داشته باشید که این یک پیاده‌سازی ممکن از اصول معماری پاک است؛ نکته کلیدی **حفظ مرزهای پاک و جدایی نگرانی‌ها** است، صرف نظر از جزئیات پیاده‌سازی خاص.

#### مسئولیت‌ها و الگوهای کنترلر

همانطور که در بررسی اجزای لایه آداپتورهای واسط دیدیم، کنترلرها در معماری پاک مجموعه‌ای متمرکز از مسئولیت‌ها دارند: **ورودی از منابع خارجی را می‌پذیرند، آن ورودی را به فرمت مورد انتظار موارد استفاده ما تبدیل و اعتبار سنجی می‌کنند، اجرای موارد استفاده را هماهنگ می‌کنند و نتایج را به طور مناسب مدیریت می‌کنند**.

اجازه دهید یک پیاده‌سازی واقعی را بررسی کنیم که این اصول را نشان می‌دهد:

```python
@dataclass
class TaskController:
    create_use_case: CreateTaskUseCase
    # ... additional use cases as needed
    presenter: TaskPresenter

    def handle_create(
        self,
        title: str,
        description: str
    ) -> OperationResult[TaskViewModel]:
        try:
            request = CreateTaskRequest(
                title=title,
                description=description
            )
            result = self.create_use_case.execute(request)
            if result.is_success:
                view_model = self.presenter.present_task(result.value)
                return OperationResult.succeed(view_model)
            error_vm = self.presenter.present_error(
                result.error.message,
                str(result.error.code.name)
            )
            return OperationResult.fail(error_vm.message, error_vm.code)
        except ValueError as e:
            error_vm = self.presenter.present_error(
                str(e), "VALIDATION_ERROR")
            return OperationResult.fail(error_vm.message, error_vm.code)

```

این کنترلر چندین اصل کلیدی معماری پاک را نشان می‌دهد. ابتدا، توجه کنید که چگونه تنها به **وابستگی‌های تزریق‌شده** وابسته است: هم مورد استفاده و هم پرزنتر در جای دیگری ساخته شده و از طریق **تزریق سازنده (constructor injection)** به کنترلر وارد می‌شوند.

برای درک اینکه چرا این الگوی **تزریق وابستگی (dependency injection)** بسیار مهم است، این مثال متقابل را در نظر بگیرید:

```python
# Anti-example: Tightly coupled controller
class TightlyCoupledTaskController:
    def __init__(self):
        # Direct instantiation creates tight coupling
        self.use_case = TaskUseCase(SqliteTaskRepository())
        self.presenter = CliTaskPresenter()

    def handle_create(self, title: str, description: str):
        # Implementation details...
        pass

```

این مثال متقابل یا ضدالگو چندین مشکل را نشان می‌دهد:

*   **ایجاد مستقیم** کلاس‌های واقعی **هم‌بستگی تنگاتنگی** ایجاد می‌کند.
*   کنترلر بیش از حد در مورد جزئیات پیاده‌سازی می‌داند.
*   تست کردن دشوار می‌شود زیرا وابستگی‌ها قابل جایگزینی نیستند.
*   تغییرات در پیاده‌سازی‌ها، تغییرات را به کنترلر تحمیل می‌کند.

بازگردیم به پیاده‌سازی پاک خود، متد `handle_create` مسئولیت‌های اصلی کنترلر را در عمل نشان می‌دهد. این متد با پذیرش **انواع اولیه** (رشته‌های `title` و `description`) از دنیای خارج آغاز می‌شود – که واسط را ساده و فریم‌ورک‌ناشناس نگه می‌دارد. این ورودی‌ها سپس به یک شیء درخواست مناسب تبدیل می‌شوند و داده‌ها را قبل از رسیدن به مورد استفاده ما اعتبار سنجی و فرمت می‌کنند.

برای اختصار، ما تنها پیاده‌سازی `handle_create` را نشان می‌دهیم، اما در عمل، این کنترلر موارد استفاده اضافی (مانند `complete_use_case`، `set_priority_use_case` و غیره) را تزریق می‌کند و متدهای هندلر مربوطه را پیاده‌سازی می‌کند. این الگوی تزریق وابستگی و پیاده‌سازی هندلر در تمام عملیات کنترلر ثابت باقی می‌ماند.

استراتژی **مدیریت خطا** کنترلر به ویژه قابل توجه است. این خطاها را قبل از رسیدن به مورد استفاده می‌گیرد و نتایج موفق و ناموفق از اجرای مورد استفاده را مدیریت می‌کند. در همه موارد، از پرزنتر برای فرمت‌بندی مناسب پاسخ‌ها برای مصرف خارجی استفاده می‌کند و آنها را در یک `OperationResult` که موارد موفقیت و شکست را صریح می‌کند، بازمی‌گرداند. این الگو بر نوع `Result` که در فصل ۵ معرفی کردیم، ساخته شده و پشتیبانی از مدل نمایش را برای فرمت‌بندی خاص واسط اضافه می‌کند. ما در مورد استفاده از `OperationResult` با جزئیات بیشتری در بخش "ساخت پرزنترها برای فرمت‌بندی داده" بحث خواهیم کرد.

این جدایی پاک از نگرانی‌ها تضمین می‌کند که منطق کسب‌وکار ما از نحوه فراخوانی آن بی‌خبر می‌ماند در حالی که یک واسط **مقاوم** و **قابل نگهداری** برای کلاینت‌های خارجی فراهم می‌کند.

#### کار با مدل‌های درخواست در کنترلرها

قبلاً `CreateTaskRequest` را در بررسی `TaskController` و در پوشش لایه کاربرد در فصل ۵ مشاهده کردیم. اکنون با دقت بیشتری بررسی می‌کنیم که چگونه کنترلرها با این مدل‌های درخواست کار می‌کنند تا مرزهای پاک بین ورودی خارجی و موارد استفاده ما را حفظ کنند:

```python
@dataclass(frozen=True)
class CreateTaskRequest:
    """Request data for creating a new task."""
    title: str
    description: str
    due_date: Optional[str] = None
    priority: Optional[str] = None

    def to_execution_params(self) -> dict:
        """Convert request data to use case parameters."""
        params = {
            "title": self.title.strip(),
            "description": self.description.strip(),
        }
        if self.priority:
            params["priority"] = Priority[self.priority.upper()]
        return params

```

در حالی که لایه کاربرد این مدل‌های درخواست را تعریف می‌کند، کنترلرها مسئول **نمونه‌سازی (instantiation)** و استفاده صحیح از آنها هستند. کنترلر تضمین می‌کند که **اعتبارسنجی ورودی** قبل از اجرای مورد استفاده رخ می‌دهد:

```python
# In TaskController
try:
    request = CreateTaskRequest(title=title, description=description)
    # Request is now validated and properly formatted
    result = self.create_use_case.execute(request)

except ValueError as e:
    # Handle validation errors before they reach use cases
    return OperationResult.fail(str(e), "VALIDATION_ERROR")

```

این جدایی تضمین می‌کند که موارد استفاده ما همیشه تنها **داده‌های معتبر و فرمت‌شده** را دریافت می‌کنند، مرزهای معماری پاک را حفظ می‌کنند در حالی که مدیریت ورودی مقاومی را فراهم می‌کنند.

#### حفظ استقلال کنترلر

کارایی لایه آداپتورهای واسط ما به شدت به **حفظ ایزولاسیون مناسب** بین کنترلرهای ما و نگرانی‌های خارجی و داخلی بستگی دارد.

اجازه دهید با دقت بیشتری بررسی کنیم که چگونه `TaskController` این استقلال را به دست می‌آورد:

```python
@dataclass
class TaskController:
    create_use_case: CreateTaskUseCase  # Application layer interface
    presenter: TaskPresenter            # Interface layer abstraction

```

این ساختار وابستگی ساده چندین اصل کلیدی را نشان می‌دهد. ابتدا، کنترلر تنها به **انتزاعیات (abstractions)** وابسته است؛ هیچ چیز در مورد پیاده‌سازی‌های واقعی مورد استفاده یا پرزنتر نمی‌داند.

اجازه دهید لحظه‌ای روشن کنیم منظورمان از **انتزاعیات در پایتون** چیست. همانطور که به زودی خواهیم دید، `TaskPresenter` از یک الگوی واسط کلاسیک با استفاده از **ABCs (Abstract Base Classes)** پایتون پیروی می‌کند و یک قرارداد واسط رسمی ایجاد می‌کند. برای موارد استفاده مانند `CreateTaskUseCase`، ما از **داک تایپینگ (duck typing)** پایتون استفاده می‌کنیم، زیرا هر مورد استفاده تنها به یک متد `execute` با پارامترها و انواع بازگشتی تعریف‌شده نیاز دارد، هر کلاسی که این متد را ارائه دهد، قرارداد واسط را بدون نیاز به فرمالیته ABC برآورده می‌کند. این انعطاف‌پذیری در تعریف واسط‌ها یکی از نقاط قوت پایتون است. ما می‌توانیم واسط‌های رسمی ABC را انتخاب کنیم زمانی که نیاز به اجرای قراردادهای پیچیده داریم یا برای واسط‌های ساده‌تر به داک تایپینگ تکیه کنیم. هر دو رویکرد اصول وابستگی معماری پاک را حفظ می‌کنند در حالی که به پایتونیک بودن کد کمک می‌کنند.

با یک بررسی ذهنی، متوجه می‌شویم چه چیزی از کنترلر ما حذف شده است:

*   **هیچ ورودی یا دکوراتور فریم‌ورک وب**.
*   **هیچ نگرانی مربوط به پایگاه داده یا ذخیره‌سازی**.
*   **هیچ نمونه‌سازی مستقیمی از وابستگی‌ها**.
*   **هیچ دانشی از پیاده‌سازی‌های نمایش واقعی**.

این ایزولاسیون دقیق به این معنی است که کنترلر ما می‌تواند توسط هر مکانیسم تحویلی استفاده شود — چه یک API وب باشد، چه یک واسط خط فرمان (CLI) یا یک مصرف‌کننده صف پیام (message queue consumer). در نظر بگیرید چه اتفاقی می‌افتد اگر این ایزولاسیون را نقض کنیم:

```python
# Anti-example: Controller with framework coupling
class WebTaskController:
    def __init__(self, app: FastAPI):
        self.app = app
        self.use_case = CreateTaskUseCase()  # Direct instantiation too!

    async def handle_create(self, request: Request):
        try:
            data = await request.json()
            # Controller now tightly coupled to FastAPI
            return JSONResponse(status_code=201, content={"task": result})
        except ValidationError as e:
            raise HTTPException(status_code=400, detail=str(e))

```

این مثال متقابل اصول ایزولاسیون ما را نقض می‌کند با:

*   **وارد کردن و وابسته بودن به یک فریم‌ورک وب خاص**.
*   **مدیریت نگرانی‌های خاص HTTP**.
*   **ترکیب مدیریت خطای فریم‌ورک با منطق کسب‌وکار**.

تصمیم در مورد نحوه نمایش عملکرد کنترلر ما به لایه **فریم‌ورک‌ها (Frameworks layer)** تعلق دارد. در فصل ۷، خواهیم دید که چگونه آداپتورهای فریم‌ورک‌محور مناسبی ایجاد کنیم که پیاده‌سازی کنترلر پاک ما را پوشش می‌دهند. این کار به ما امکان می‌دهد تا مرزهای معماری پاک را حفظ کنیم در حالی که همچنان از تمام قابلیت‌های فریم‌ورک‌هایی مانند FastAPI، Click برای خط فرمان، یا کتابخانه‌های صف پیام بهره‌مند شویم.

واسط‌هایی که کنترلر ما به آنها وابسته است، **توجه دقیق معماری پاک به مرزها** را نشان می‌دهند: واسط‌های مورد استفاده که توسط لایه کاربرد تعریف شده‌اند، وابستگی‌های داخلی ما را ایجاد می‌کنند، در حالی که واسط‌های پرزنتر که در لایه آداپتورهای واسط ما تعریف شده‌اند، به ما کنترل بر جریان داده خروجی را می‌دهند. این چیدمان دقیق واسط‌ها تضمین می‌کند که **قانون وابستگی** را حفظ می‌کنیم در حالی که سیستم خود را انعطاف‌پذیر و قابل انطباق نگه می‌دارد.

### اعمال مرزها از طریق آداپتورهای واسط

در حالی که بررسی کنترلرها نحوه مدیریت درخواست‌های ورودی را نشان داد، **مرزهای واسطی معماری پاک** نیازمند توجه دقیق به جریان داده در هر دو جهت هستند. در این بخش، الگوهایی را برای حفظ مرزهای پاک در سراسر سیستم خود، به ویژه با تمرکز بر **مدیریت صریح موارد موفقیت و شکست**، بررسی خواهیم کرد. این الگوها مکمل کنترلرها و پرزنترهای ما هستند در حالی که تضمین می‌کنند تمام ارتباطات متقاطع مرزی **واضح و قابل نگهداری** باقی می‌مانند.

#### الگوهای صریح موفقیت/شکست در مرزها

در مرزهای معماری خود، به روش‌های واضح و منسجمی برای مدیریت **عملیات موفق و شکست‌ها** نیاز داریم. عملیات ممکن است به دلایل مختلفی شکست بخورند – ورودی نامعتبر، نقض قوانین کسب‌وکار یا خطاهای سیستمی – و هر نوع شکست ممکن است نیاز به مدیریت متفاوتی توسط واسط خارجی داشته باشد. به همین ترتیب، عملیات موفق باید نتایج خود را در فرمتی مناسب برای واسطی که آنها را درخواست کرده است، ارائه دهند. ما این مکانیزم را قبلاً در مثال‌های کنترلر نشان داده شده مشاهده کرده‌ایم.

```python
class TaskController:
    def handle_create(
        self,
        title: str,
        description: str
    ) -> OperationResult[TaskViewModel]:
```

الگوی `OperationResult` این نیازها را با ارائه یک روش استاندارد برای مدیریت هر دو مورد موفقیت و شکست برطرف می‌کند. این الگو تضمین می‌کند که آداپتورهای واسط ما همیشه نتایج را **به صراحت** ارتباط می‌دهند، که نادیده گرفتن موارد خطا را غیرممکن می‌سازد و یک ساختار واضح برای سناریوهای موفقیت فراهم می‌کند:

```python
@dataclass
class OperationResult(Generic[T]):
    """Represents the outcome of controller operations."""
    _success: Optional[T] = None
    _error: Optional[ErrorViewModel] = None

    @classmethod
    def succeed(cls, value: T) -> 'OperationResult[T]':
        """Create a successful result with the given view model."""
        return cls(_success=value)

    @classmethod
    def fail(cls, message: str,
             code: Optional[str] = None) -> 'OperationResult[T]':
        """Create a failed result with error details."""
        return cls(_error=ErrorViewModel(message, code))

```

توجه کنید که چگونه کلاس به عنوان `OperationResult(Generic[T])` تعریف شده است. این بدان معناست که کلاس ما می‌تواند با هر نوع `T` کار کند. هنگامی که کلاس را نمونه‌سازی می‌کنیم، `T` را با یک نوع خاص جایگزین می‌کنیم — به عنوان مثال، هنگامی که `OperationResult[TaskViewModel]` را می‌نویسیم، می‌گوییم: این عملیات یا با یک `TaskViewModel` موفق می‌شود یا با یک خطا (`ErrorViewModel`) شکست می‌خورد. این **ایمنی نوع (type safety)** به ما کمک می‌کند تا خطاهای احتمالی را زودتر بگیریم در حالی که هدف کد ما را واضح‌تر می‌کند.

این مدیریت صریح نتایج، پایه‌ای برای **عبور مرزی پاک** فراهم می‌کند که در سراسر آداپتورهای واسط ما اعمال خواهد شد. همانطور که به الگوهای تبدیل داده می‌پردازیم، خواهیم دید که چگونه این وضوح در مدیریت موفقیت و شکست به حفظ مرزهای معماری پاک در عین امکان‌پذیری عملکرد عملی کمک می‌کند.

اگر به برخی از کدهای برنامه (که در لایه فریم‌ورک‌ها قرار دارند) نگاه کنیم، می‌بینیم که چگونه می‌توان از این `OperationResult` برای هدایت جریان برنامه استفاده کرد:

```python
# pseudo-code example of a CLI app working with a OperationResult
result = app.task_controller.handle_create(title, description)

if result.is_success:
    task = result.success
    print(f"{task.status_display} [{task.priority_display}] {task.title}")
    return 0
print(result.error.message, fg='red', err=True)
return 1

```

#### جریان‌های تبدیل داده پاک

همانطور که داده‌ها از طریق مرزهای معماری ما حرکت می‌کنند، چندین تبدیل را تجربه می‌کنند. درک این جریان‌های تبدیل به ما کمک می‌کند تا مرزهای پاک را حفظ کنیم در حالی که اطمینان حاصل می‌کنیم سیستم ما قابل نگهداری باقی می‌ماند:

```python
# Example transformation flow in TaskController
def handle_create(
    self, title: str, description: str
) -> OperationResult[TaskViewModel]:
    try:
        # 1. External input to request model
        request = CreateTaskRequest(title=title, description=description)
        # 2. Request model to domain operations
        result = self.use_case.execute(request)
        if result.is_success:
            # 3. Domain result to view model
            view_model = self.presenter.present_task(result.value)
            return OperationResult.succeed(view_model)
        # 4. Error handling and formatting
        error_vm = self.presenter.present_error(
            result.error.message,
            str(result.error.code.name)
        )
        return OperationResult.fail(error_vm.message, error_vm.code)
    except ValueError as e:
        # 5. Validation error handling
        error_vm = self.presenter.present_error(
            str(e), "VALIDATION_ERROR")
        return OperationResult.fail(error_vm.message, error_vm.code)

```

این مثال یک زنجیره تبدیل کامل را نشان می‌دهد:

1.  **اعتبار سنجی و تبدیل ورودی خارجی**.
2.  **اجرای مورد استفاده با انواع دامین**.
3.  **تبدیل مورد موفقیت به مدل نمایش**.
4.  **مدیریت و فرمت‌بندی مورد خطا**.
5.  **مدیریت خطای اعتبارسنجی**.

هر مرحله در این زنجیره **مرزهای پاک** را حفظ می‌کند در حالی که اطمینان حاصل می‌کند داده‌ها به درستی بین لایه‌ها حرکت می‌کنند.

#### آداپتورهای واسط و مرزهای معماری

در حالی که ما بر کنترلرها و پرزنترها به عنوان آداپتورهای واسط کلیدی تمرکز کرده‌ایم، هر تعاملی بین لایه‌ها نیاز به یک آداپتور ندارد. درک اینکه چه زمانی آداپتورها مورد نیاز هستند به ما کمک می‌کند تا معماری پاک را بدون پیچیدگی غیرضروری حفظ کنیم.

```python
# Defined in Application layer
class TaskRepository(ABC):
    @abstractmethod
    def get(self, task_id: UUID) -> Task:
        """Retrieve a task by its ID."""
        pass

# Implemented directly in Infrastructure layer
class SqliteTaskRepository(TaskRepository):
    def get(self, task_id: UUID) -> Task:
        # Direct implementation of interface
        pass

```

در اینجا نیازی به آداپتور نیست زیرا:

*   لایه کاربرد واسط دقیقی را که مورد نیاز است تعریف می‌کند.
*   پیاده‌سازی می‌تواند به طور مستقیم این واسط را برآورده کند.
*   هیچ تبدیل فرمت داده‌ای مورد نیاز نیست.
*   قانون وابستگی بدون نیاز به آداپتور حفظ می‌شود.

این با کنترلرها و پرزنترها که باید فرمت‌ها و پروتکل‌های خارجی مختلف را مدیریت کنند، متفاوت است. سوال کلیدی در هنگام تصمیم‌گیری در مورد نیاز به آداپتور این است: **آیا این تعامل نیاز به تبدیل فرمت بین لایه‌ها دارد؟** اگر لایه بیرونی بتواند مستقیماً با واسط تعریف‌شده توسط لایه داخلی کار کند، ممکن است نیازی به آداپتور در لایه واسط نباشد.

این تمایز به ما کمک می‌کند تا اصول معماری پاک را حفظ کنیم در حالی که از انتزاع غیرضروری جلوگیری می‌کنیم. با درک اینکه چه زمانی آداپتورها مورد نیاز هستند، می‌توانیم سیستم‌های قابل نگهداری‌تری ایجاد کنیم که مرزهای معماری را بدون پیچیده‌تر کردن بیش از حد طراحی ما رعایت می‌کنند.

### ساخت پرزنترها برای فرمت‌بندی داده

در طول این فصل، ما به پرزنترها به عنوان اجزای کلیدی لایه آداپتورهای واسط خود اشاره کرده‌ایم. اکنون آنها را با جزئیات بررسی می‌کنیم و می‌بینیم که چگونه آنها مرزهای معماری پاک را حفظ می‌کنند در حالی که داده‌های دامین را برای مصرف خارجی آماده می‌کنند.

پرزنترها مکمل کنترلرهای ما هستند و جریان خروجی داده‌ها را درست مانند کنترلرها که درخواست‌های ورودی را مدیریت می‌کنند، مدیریت می‌کنند. با پیاده‌سازی الگوی **شیء فروتن (humble object pattern)**، پرزنترها به ما کمک می‌کنند تا سیستم‌های قابل تست‌تر و قابل نگهداری‌تری ایجاد کنیم در حالی که نماهای ما ساده و متمرکز باقی می‌مانند.

#### درک الگوی شیء فروتن

الگوی شیء فروتن یک چالش رایج در معماری پاک را حل می‌کند: **چگونگی مدیریت منطق نمایش (presentation logic) که اغلب در برابر تست واحد مقاومت می‌کند، در حالی که مرزهای معماری پاک حفظ می‌شوند**.

اصطلاح **شیء فروتن (humble object)** از استراتژی ساخت یک جزء تا حد امکان ساده و عاری از منطق پیچیده نشات می‌گیرد. در زمینه‌های نمایش، این به معنای ایجاد یک **نمای بسیار ساده** است که کاری جز نمایش داده‌های از پیش فرمت‌شده انجام نمی‌دهد. نما با طراحی خود فروتن می‌شود و حداقل هوش را در خود دارد.

به عنوان مثال، یک نمای فروتن ممکن است:

*   یک **قالب HTML ساده** باشد که داده‌های از پیش فرمت‌شده را رندر می‌کند.
*   یک **کامپوننت React** باشد که فقط props‌های ارسالی را نمایش می‌دهد.
*   یک **تابع نمایش CLI** باشد که رشته‌های فرمت‌شده را چاپ می‌کند.

این الگو مسئولیت‌ها را بین دو جزء تقسیم می‌کند:

*   یک **نمای فروتن** که حاوی حداقل منطق است که تست آن دشوار است.
*   یک **پرزنتر** که تمام منطق نمایش را در یک قالب قابل تست به راحتی تست می‌کند.

در نظر بگیرید که چگونه سیستم مدیریت وظایف ما ممکن است اطلاعات وظیفه را در یک CLI نمایش دهد:

```python
# The "humble" view - simple, minimal logic, hard to test
def display_task(task_vm: TaskViewModel):
    print(f"{task_vm.status_display} [{task_vm.priority_display}] "
          f"{task_vm.title}")
    if task_vm.due_date_display:
        print(f"Due: {task_vm.due_date_display}")

```

تمام تصمیمات فرمت‌بندی – نحوه نمایش وضعیت، سطوح اولویت، تاریخ‌ها – در پرزنتر ما قرار دارند، نه خود مدل نمایش (`TaskViewModel`). این جدایی چندین مزیت دارد:

*   نماها ساده و متمرکز بر نمایش باقی می‌مانند.
*   منطق نمایش قابل تست باقی می‌ماند.
*   قوانین کسب‌وکار از نگرانی‌های نمایش ایزوله می‌مانند.
*   چندین واسط می‌توانند منطق فرمت‌بندی را به اشتراک بگذارند.

شایان ذکر است که تأکید بر پرزنترها می‌تواند بر اساس نیازهای خاص شما متفاوت باشد. اگر در حال ساخت یک API پایتون هستید که داده‌ها را به یک فرانت‌اند جاوااسکریپت ارائه می‌دهد، ممکن است به منطق نمایش حداقل نیاز داشته باشید. با این حال، در برنامه‌های پایتون فول‌استک که از فریم‌ورک‌هایی مانند جنگو (Django) یا فلاسک (Flask) استفاده می‌کنند، پرزنترهای قدرتمند به حفظ جدایی پاک بین منطق کسب‌وکار و نگرانی‌های نمایش کمک می‌کنند. درک الگو به شما امکان می‌دهد تا بر اساس شرایط خود تصمیمات آگاهانه بگیرید.

#### تعریف واسط‌های پرزنتر

موفقیت معماری پاک به شدت به **واسط‌های خوش‌تعریف (well-defined interfaces)** در مرزهای معماری بستگی دارد. برای پرزنترها، این واسط‌ها قراردادهای واضحی را برای تبدیل داده‌های دامین به فرمت‌های آماده نمایش ایجاد می‌کنند:

```python
class TaskPresenter(ABC):
    """Abstract base presenter for task-related output."""
    @abstractmethod
    def present_task(self, task_response: TaskResponse) -> TaskViewModel:
        """Convert task response to view model."""
        pass

    @abstractmethod
    def present_error(self, error_msg: str,
                      code: Optional[str] = None) -> ErrorViewModel:
        """Format error message for display."""
        pass

```

این واسط، که در لایه آداپتورهای واسط ما تعریف شده است، چندین هدف کلیدی را دنبال می‌کند:

*   **قرارداد واضحی را برای نمایش وظیفه** ایجاد می‌کند.
*   چندین پیاده‌سازی واسط را امکان‌پذیر می‌سازد.
*   **قانون وابستگی** را با بی‌خبر نگه داشتن منطق دامین از جزئیات نمایش حفظ می‌کند.
*   تست‌پذیری را از طریق انتزاع واضح آسان‌تر می‌کند.

توجه کنید که چگونه واسط از **انواع خاص دامین** (`TaskResponse`) به عنوان ورودی استفاده می‌کند اما **انواع خاص نمایش** (`TaskViewModel`) را برمی‌گرداند. این عبور مرزی جایی است که ما مفاهیم دامین را به فرمت‌های دوست‌دار نمایش تبدیل می‌کنیم.

#### کار با مدل‌های نمایش (View Models)

مدل‌های نمایش (View models) به عنوان **حامل‌های داده** بین پرزنترها و نماها عمل می‌کنند و **جدایی پاکی** بین منطق نمایش و نگرانی‌های نمایش را تضمین می‌کنند. آنها داده‌های فرمت‌شده را به گونه‌ای کپسوله می‌کنند که هر پیاده‌سازی نمایشی می‌تواند به راحتی آنها را مصرف کند:

```python
@dataclass(frozen=True)
class TaskViewModel:
    """View-specific representation of a task."""
    id: str
    title: str
    description: str
    status_display: str      # Pre-formatted for display
    priority_display: str    # Pre-formatted for display
    due_date_display: Optional[str]  # Pre-formatted for display
    project_display: Optional[str]   # Pre-formatted project context
    completion_info: Optional[str]   # Pre-formatted completion details

```

چندین اصل کلیدی طراحی مدل نمایش ما را هدایت می‌کنند:

*   **فقط از انواع اولیه (primitive types)** (رشته‌ها، اعداد، بولی‌ها) استفاده کنید.
*   تمام متن نمایش را **از پیش فرمت کنید**.
*   **هیچ فرضیه‌ای در مورد مکانیزم نمایش** نداشته باشید.
*   **تغییرناپذیر (immutable)** باقی بمانید (به `frozen=True` توجه کنید).
*   **فقط داده‌های مورد نیاز برای نمایش** را شامل شود.

این سادگی تضمین می‌کند که نماهای ما واقعاً فروتن (humble) باقی می‌مانند – آنها فقط نیاز به خواندن و نمایش این مقادیر از پیش فرمت‌شده دارند، بدون هیچ دانشی از مفاهیم دامین یا قوانین فرمت‌بندی.

#### پیاده‌سازی پرزنترهای واقعی

با تعریف واسط‌های پرزنتر و مدل‌های نمایش، می‌توانیم پرزنترهای واقعی را برای نیازهای واسط خاص پیاده‌سازی کنیم. این پرزنترهای واقعی در لایه فریم‌ورک‌ها و درایورها (Frameworks and Drivers layer) پیاده‌سازی می‌شوند، اما برای درک بهتر، یک نگاه اجمالی در اینجا به شما می‌دهیم. بیایید یک پیاده‌سازی پرزنتر خاص CLI را بررسی کنیم:

```python
class CliTaskPresenter(TaskPresenter):
    """CLI-specific task presenter."""
    def present_task(self, task_response: TaskResponse) -> TaskViewModel:
        """Format task for CLI display."""
        return TaskViewModel(
            id=str(task_response.id),
            title=task_response.title,
            description=task_response.description,
            status_display=self._format_status(task_response.status),
            priority_display=self._format_priority(
                task_response.priority),
            due_date_display=self._format_due_date(
                task_response.due_date),
            project_display=self._format_project(
                task_response.project_id),
            completion_info=self._format_completion_info(
                task_response.completion_date,
                task_response.completion_notes
            )
        )

```

متد `present_task` مدل `TaskResponse` خاص دامین ما را به یک `TaskViewModel` دوست‌دار نمایش تبدیل می‌کند. برای پشتیبانی از این تبدیل، پرزنتر چندین متد فرمت‌بندی خصوصی را پیاده‌سازی می‌کند که جنبه‌های خاصی از داده‌ها را مدیریت می‌کنند:

```python
class CliTaskPresenter(TaskPresenter):  # continuing from above

    def _format_due_date(self, due_date: Optional[datetime]) -> str:
        """Format due date, indicating if task is overdue."""
        if not due_date:
            return "No due date"
        is_overdue = due_date < datetime.now(timezone.utc)
        date_str = due_date.strftime("%Y-%m-%d")
        return (
            f"OVERDUE - Due: {date_str}"
            if is_overdue else f"Due: {date_str}"
        )

    def present_error(self, error_msg: str,
                      code: Optional[str] = None) -> ErrorViewModel:
        """Format error message for CLI display."""
        return ErrorViewModel(message=error_msg, code=code)

```

این پیاده‌سازی چندین اصل کلیدی معماری پاک را نشان می‌دهد:

*   تمام منطق فرمت‌بندی در پرزنتر قرار دارد، نه در نماها.
*   مفاهیم دامین (مانند `TaskStatus`) به رشته‌های نمایش تبدیل می‌شوند.
*   مدیریت خطا با موارد موفقیت سازگار باقی می‌ماند.
*   فرمت‌بندی خاص واسط (در این مورد CLI) ایزوله باقی می‌ماند.

متدهای فرمت‌بندی پرزنتر بسیار قابل تست باقی می‌مانند: می‌توانیم بررسی کنیم که وظایف سررسیدشده به درستی علامت‌گذاری شده‌اند، تاریخ‌ها به درستی فرمت شده‌اند و پیام‌های خطا سازگاری خود را حفظ می‌کنند. این تست‌پذیری در تضاد شدید با تست مستقیم اجزای واسط کاربری است و یک مزیت کلیدی الگوی شیء فروتن را نشان می‌دهد.

در فصل ۷، خواهیم دید که چگونه واسط‌های مختلف (CLI، وب یا API) می‌توانند پرزنترهای خود را پیاده‌سازی کنند در حالی که این معماری مشترک را به اشتراک می‌گذارند. این انعطاف‌پذیری نشان می‌دهد که چگونه توجه دقیق معماری پاک به مرزها، امکان تکامل سیستم را بدون به خطر انداختن منطق اصلی کسب‌وکار فراهم می‌کند.

با بررسی کنترلرها و پرزنترها، اکنون یک لایه آداپتورهای واسط کامل برای سیستم مدیریت وظایف خود پیاده‌سازی کرده‌ایم. اجازه دهید لحظه‌ای پیشرفت معماری خود را با بررسی ساختاری که در طول فصل‌های ۴ تا ۶ ساخته‌ایم، مرور کنیم:

محل دیاگرام 6.3

<div dir="rtl" style="text-align: right;">

**شکل ۶.۳: ساختار پوشه با تمام لایه‌ها در جای خود**

**انعطاف‌پذیری پیاده‌سازی**
اگر در حال ساخت یک API هستید که عمدتاً JSON را به یک فرانت‌اند جاوااسکریپت ارائه می‌دهد، ممکن است به منطق نمایش حداقل نیاز داشته باشید. الگوی پرزنتر زمانی با ارزش‌ترین می‌شود که به فرمت‌بندی پیچیده یا پشتیبانی از انواع واسط متعدد نیاز داشته باشید.

این ساختار منعکس‌کننده لایه‌های متحدالمرکز معماری پاک است. لایه دامین ما، که در فصل ۴ ایجاد شد، خالص و متمرکز بر قوانین کسب‌وکار باقی می‌ماند. لایه کاربرد، که در فصل ۵ اضافه شد، این موجودیت‌های دامین را برای انجام موارد استفاده خاص سازماندهی می‌کند. اکنون، با لایه آداپتورهای واسط، کنترلرها و پرزنترهایی را پیاده‌سازی کرده‌ایم که بین منطق اصلی کسب‌وکار ما و نگرانی‌های خارجی ترجمه می‌کنند، مرزهای پاک را حفظ می‌کنند در حالی که تعامل عملی با سیستم ما را امکان‌پذیر می‌سازند. برای مشاهده مثال کد گسترده‌تر از برنامه مدیریت وظایف که در طول کتاب استفاده می‌شود، به مخزن گیت‌هاب همراه مراجعه کنید.

### خلاصه

در این فصل، لایه آداپتورهای واسط معماری پاک را بررسی کردیم، کنترلرها و پرزنترهایی را پیاده‌سازی کردیم که مرزهای پاک را حفظ می‌کنند در حالی که تعامل عملی با سیستم‌های خارجی را امکان‌پذیر می‌سازند. آموختیم که چگونه کنترلرها درخواست‌های ورودی را مدیریت می‌کنند، ورودی خارجی را به فرمت‌هایی تبدیل می‌کنند که موارد استفاده ما می‌توانند پردازش کنند، در حالی که پرزنترها داده‌های دامین را به فرمت‌های دوست‌دار نمایش تبدیل می‌کنند.

با استفاده از سیستم مدیریت وظایف خود به عنوان مثال، دیدیم که چگونه کنترلرهایی را پیاده‌سازی کنیم که مستقل از منابع ورودی خاص باشند و پرزنترهایی که منطق فرمت‌بندی را از جزئیات پیاده‌سازی نمایش جدا می‌کنند. ما بر الگوی `Result` از فصل ۵ بنا کردیم، `OperationResult` را برای مدیریت صریح موفقیت و شکست در مرزهای معماری خود معرفی کردیم. الگوی شیء فروتن به ما نشان داد که چگونه جدایی پاکی بین منطق نمایش و نماها را حفظ کنیم، که هر دو تست‌پذیری و نگهداری‌پذیری را بهبود می‌بخشد.

در فصل ۷، بررسی خواهیم کرد که چگونه واسط‌های خاصی را پیاده‌سازی کنیم که کنترلرها و پرزنترهای ما را مصرف می‌کنند. خواهید آموخت که چگونه واسط‌های خط فرمان و وب را ایجاد کنید که با سیستم ما تعامل داشته باشند در حالی که مرزهای پاکی را که ایجاد کرده‌ایم حفظ می‌کنند.

### مطالعه بیشتر

برای یادگیری بیشتر در مورد موضوعاتی که در این فصل پوشش داده شد، به منابع زیر مراجعه کنید:

*   **Clean DDD Lessons: Presenters**: بحثی در مورد رویکردها به پرزنترها در معماری پاک.
*   **Implementing Clean Architecture—Are Asp.Net Controllers “Clean”?**: مقاله‌ای عمیق که جوانب مثبت و منفی رویکردهای متعدد برای پیاده‌سازی نماها در معماری پاک را مورد بحث قرار می‌دهد.

</div>